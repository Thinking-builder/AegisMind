# 恶意程序检测系统 - 后端功能实现说明

## 1. 文档概述

###文档目的
本文档详细说明恶意程序检测系统后端的功能实现方案，包括系统架构、功能模块、技术选型、实现逻辑等，为后端开发提供指导。
---

## 2. 系统架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                     前端 Web 界面                         │
└────────────────────┬────────────────────────────────────┘
                     │ HTTP/HTTPS
┌────────────────────▼────────────────────────────────────┐
│                  API 网关层                               │
│  (路由分发、请求验证、身份认证、限流)                      │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                业务逻辑层 (Service Layer)                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ 文件处理服务  │  │ 检测调度服务  │  │ 报告生成服务  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ 结果整合服务  │  │ 性能评估服务  │  │ LLM集成服务  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│              检测引擎适配层 (Adapter Layer)                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ YARA引擎适配  │  │ AI模型适配   │  │ Sigma引擎适配 │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│              外部服务/引擎层                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ YARA引擎     │  │ AI模型服务   │  │ Sigma引擎     │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│  ┌──────────────┐                                        │
│  │ LLM API服务  │                                        │
│  └──────────────┘                                        │
└──────────────────────────────────────────────────────────┘
```

### 2.2 技术栈建议

**后端框架：**
- Python: Flask / FastAPI / Django
- Node.js: Express / Koa
- Java: Spring Boot
- Go: Gin / Echo

**推荐方案：** FastAPI (Python)
- 异步支持好，适合文件处理
- API文档自动生成
- 类型检查支持

**数据存储：**
- 临时文件存储：本地文件系统 / 对象存储 (MinIO / S3)
- 检测结果缓存：Redis (可选)
- 元数据存储：SQLite / PostgreSQL / MySQL

**任务队列（批量检测）：**
- Celery (Python) + Redis
- Bull (Node.js) + Redis
- 或使用异步处理

---

## 3. 核心功能模块实现

### 3.1 文件处理服务 (File Processing Service)

#### 3.1.1 功能描述
负责接收、验证、存储和管理上传的文件。

#### 3.1.2 实现要点

**文件接收：**
- 支持单文件上传（单样本模式）
- 支持多文件上传（批量模式）
- 支持大文件分块上传（如需要）
- 文件大小限制：建议单文件最大 100MB

**文件验证：**
- 文件类型验证（基于文件扩展名和MIME类型）
- 文件大小验证
- 恶意文件检查（防止上传恶意脚本攻击服务器）
- 文件完整性校验（MD5/SHA256）

**文件存储：**
- 临时存储路径：`/tmp/uploads/{session_id}/{timestamp}_{filename}`
- 文件命名规则：使用UUID或时间戳避免冲突
- 存储元数据：文件名、大小、类型、上传时间、MD5值

**文件类型识别：**
```python
# 伪代码示例
def identify_file_type(file_path):
    # 1. 读取文件头（Magic Number）
    with open(file_path, 'rb') as f:
        header = f.read(16)
    
    # 2. 检查文件扩展名
    ext = get_extension(file_path)
    
    # 3. 判断文件类型
    if is_pe_file(header):
        return 'PE'
    elif is_evtx_file(header, ext):
        return 'EVTX'
    elif is_script_file(ext):
        return 'SCRIPT'
    else:
        return 'UNKNOWN'
```

**文件清理：**
- 检测完成后自动清理临时文件
- 设置文件过期时间（如：24小时后自动删除）
- 提供手动清理接口

---

### 3.2 检测调度服务 (Detection Scheduler Service)

#### 3.2.1 功能描述
根据文件类型和用户选择，调度相应的检测模块执行检测任务。

#### 3.2.2 实现要点

**模块激活逻辑：**
```python
# 伪代码示例
def activate_modules(file_type):
    modules = []
    
    if file_type != 'EVTX':
        modules.append('static')      # 静态检测
        modules.append('ai')          # AI检测
    
    if file_type == 'EVTX':
        modules.append('dynamic')     # 动态检测
    
    return modules
```

**检测执行流程：**
1. 接收检测请求（文件路径、激活模块列表）
2. 按模块顺序串行执行检测
3. 收集每个模块的检测结果
4. 整合所有结果返回

**错误处理：**
- 单个模块失败不影响其他模块执行
- 记录失败原因和错误日志
- 返回部分结果（已成功执行的模块结果）

**进度反馈：**
- 单样本模式：返回当前执行模块和进度百分比
- 批量模式：返回当前处理文件索引和总文件数

---

### 3.3 静态检测模块适配器 (Static Detection Adapter)

#### 3.3.1 功能描述
适配YARA规则引擎，对PE文件进行静态特征检测。

#### 3.3.2 实现要点

**YARA引擎集成：**
- 使用YARA Python库 (`yara-python`)
- 加载YARA规则文件（`.yar`文件）
- 对文件进行规则匹配

**接口封装：**
```python
# 伪代码示例
def static_detection(file_path):
    try:
        # 1. 加载YARA规则
        rules = yara.compile(filepath='rules/malware.yar')
        
        # 2. 执行匹配
        matches = rules.match(file_path)
        
        # 3. 格式化结果
        result = {
            'module': 'static',
            'status': 'success',
            'matches': [
                {
                    'rule_name': match.rule,
                    'tags': match.tags,
                    'strings': match.strings
                }
                for match in matches
            ],
            'is_malicious': len(matches) > 0
        }
        
        return result
    except Exception as e:
        return {
            'module': 'static',
            'status': 'error',
            'error': str(e)
        }
```

**规则管理：**
- 规则文件存储路径：`/rules/yara/`
- 支持规则热更新（无需重启服务）
- 规则版本管理

**性能优化：**
- 规则预编译缓存
- 大文件分块扫描（如需要）

---

### 3.4 人工智能检测模块适配器 (AI Detection Adapter)

#### 3.4.1 功能描述
适配AI模型服务，对文件进行机器学习分析。

#### 3.4.2 实现要点

**模型服务集成方式：**
- **方式1：** 本地模型（TensorFlow/PyTorch模型文件）
- **方式2：** 远程API服务（HTTP/gRPC调用）
- **方式3：** 模型服务容器（Docker部署）

**特征提取：**
- PE文件特征提取（如：导入表、导出表、节信息等）
- 文件特征向量化
- 特征标准化处理

**模型调用：**
```python
# 伪代码示例
def ai_detection(file_path):
    try:
        # 1. 特征提取
        features = extract_features(file_path)
        
        # 2. 调用模型服务
        # 方式1：本地模型
        prediction = model.predict(features)
        
        # 方式2：远程API
        # response = requests.post('http://ai-service/api/predict', 
        #                         json={'features': features})
        # prediction = response.json()
        
        # 3. 格式化结果
        result = {
            'module': 'ai',
            'status': 'success',
            'prediction': {
                'is_malicious': prediction['is_malicious'],
                'confidence': prediction['confidence'],
                'malware_family': prediction.get('family', None)
            }
        }
        
        return result
    except Exception as e:
        return {
            'module': 'ai',
            'status': 'error',
            'error': str(e)
        }
```

**结果解释：**
- 返回恶意概率（0-1之间的浮点数）
- 返回恶意软件家族分类（如：Trojan、Ransomware等）
- 返回置信度分数

---

### 3.5 动态检测模块适配器 (Dynamic Detection Adapter)

#### 3.5.1 功能描述
适配Sigma规则引擎，对EVTX文件进行威胁行为检测。

#### 3.5.2 实现要点

**EVTX文件解析：**
- 使用Python库解析EVTX文件（如：`evtx`库）
- 提取Windows事件日志记录
- 转换为结构化数据

**Sigma规则集成：**
- 使用Sigma规则引擎（如：`sigma`库或自定义解析器）
- 加载Sigma规则文件（`.yml`文件）
- 对日志事件进行规则匹配

**实现示例：**
```python
# 伪代码示例
def dynamic_detection(file_path):
    try:
        # 1. 解析EVTX文件
        events = parse_evtx(file_path)
        
        # 2. 加载Sigma规则
        rules = load_sigma_rules('rules/sigma/')
        
        # 3. 执行匹配
        matches = []
        for event in events:
            for rule in rules:
                if rule.matches(event):
                    matches.append({
                        'rule_id': rule.id,
                        'rule_name': rule.title,
                        'event_id': event.id,
                        'timestamp': event.timestamp
                    })
        
        # 4. 格式化结果
        result = {
            'module': 'dynamic',
            'status': 'success',
            'matches': matches,
            'total_events': len(events),
            'matched_events': len(set(m['event_id'] for m in matches)),
            'is_malicious': len(matches) > 0
        }
        
        return result
    except Exception as e:
        return {
            'module': 'dynamic',
            'status': 'error',
            'error': str(e)
        }
```

**规则管理：**
- 规则文件存储路径：`/rules/sigma/`
- 支持规则分类（按威胁类型）
- 规则优先级管理

---

### 3.6 结果整合服务 (Result Integration Service)

#### 3.6.1 功能描述
整合多个检测模块的结果，生成统一的结果格式。

#### 3.6.2 实现要点

**结果数据结构：**
```json
{
    "file_info": {
        "filename": "sample.exe",
        "file_type": "PE",
        "file_size": 1024000,
        "md5": "abc123...",
        "upload_time": "2024-01-01T10:00:00Z"
    },
    "detection_results": [
        {
            "module": "static",
            "status": "success",
            "is_malicious": true,
            "details": { ... }
        },
        {
            "module": "ai",
            "status": "success",
            "is_malicious": true,
            "details": { ... }
        }
    ],
    "final_verdict": {
        "is_malicious": true,
        "confidence": 0.95,
        "reason": "多个检测模块均判定为恶意"
    }
}
```

**结果合并逻辑：**
- 如果任一模块判定为恶意，最终判定为恶意
- 计算综合置信度（加权平均或投票机制）
- 生成判定理由说明

---

### 3.7 LLM集成服务 (LLM Integration Service)

#### 3.7.1 功能描述
集成大语言模型API，生成专业的恶意程序分析报告。

#### 3.7.2 实现要点

**支持的LLM服务：**
- OpenAI GPT系列
- Anthropic Claude
- 国产大模型（文心一言、通义千问、智谱GLM等）

**提示词构建：**
```python
# 伪代码示例
def build_prompt(detection_results, internet_enabled):
    prompt = f"""基于以下检测信息，请生成一份专业的恶意程序分析报告：

【静态检测结果】
{format_static_results(detection_results.get('static'))}

【人工智能检测结果】
{format_ai_results(detection_results.get('ai'))}

【动态检测结果】
{format_dynamic_results(detection_results.get('dynamic'))}

请基于以上信息，输出一份Markdown格式的病毒分析报告，报告应包含：
1. 样本基本信息
2. 威胁等级评估
3. 检测结果汇总
4. 行为分析
5. 威胁情报关联{"（可联网查询最新威胁情报）" if internet_enabled else ""}
6. 防护建议
"""
    return prompt
```

**API调用封装：**
```python
# 伪代码示例
def generate_report(prompt, internet_enabled):
    # 根据配置选择LLM服务
    llm_config = get_llm_config()
    
    if llm_config['provider'] == 'openai':
        return call_openai_api(prompt, internet_enabled)
    elif llm_config['provider'] == 'claude':
        return call_claude_api(prompt, internet_enabled)
    # ... 其他LLM服务
    
def call_openai_api(prompt, internet_enabled):
    import openai
    
    # 设置联网参数（如果API支持）
    params = {
        'model': 'gpt-4',
        'messages': [
            {'role': 'system', 'content': '你是一名专业的恶意程序分析专家。'},
            {'role': 'user', 'content': prompt}
        ],
        'temperature': 0.7,
        'max_tokens': 4000
    }
    
    # 如果API支持联网功能，添加参数
    if internet_enabled:
        params['enable_internet'] = True  # 根据实际API文档调整
    
    response = openai.ChatCompletion.create(**params)
    return response.choices[0].message.content
```

**错误处理：**
- API调用超时处理（建议30-60秒）
- 重试机制（最多3次）
- 降级方案（API失败时返回基础报告模板）

**成本控制：**
- Token使用量统计
- 请求频率限制
- 缓存机制（相同检测结果可复用报告）

---

### 3.8 批量检测服务 (Batch Detection Service)

#### 3.8.1 功能描述
处理批量文件检测任务，支持并发处理和进度跟踪。

#### 3.8.2 实现要点

**任务队列设计：**
- 使用任务队列（Celery/Bull）或异步处理
- 支持任务优先级
- 支持任务取消

**并发控制：**
- 控制并发数量（如：最多同时处理5个文件）
- 避免资源竞争
- 合理分配服务器资源

**进度跟踪：**
```python
# 伪代码示例
def batch_detection(file_list, modules, ground_truth=None):
    total_files = len(file_list)
    results = []
    
    for index, file_path in enumerate(file_list):
        # 更新进度
        progress = {
            'current': index + 1,
            'total': total_files,
            'percentage': (index + 1) / total_files * 100,
            'current_file': file_path
        }
        update_progress(progress)
        
        # 执行检测
        result = execute_detection(file_path, modules)
        results.append(result)
    
    # 性能评估（如果提供Ground Truth）
    if ground_truth:
        evaluation = performance_evaluation(results, ground_truth)
        return {
            'results': results,
            'evaluation': evaluation
        }
    
    return {'results': results}
```

**结果汇总：**
- 统计检测结果（恶意/良性数量）
- 生成汇总报告
- 支持结果导出（CSV/JSON）

---

### 3.9 性能评估服务 (Performance Evaluation Service)

#### 3.9.1 功能描述
根据Ground Truth数据，计算检测系统的性能指标。

#### 3.9.2 实现要点

**Ground Truth解析：**
```python
# 伪代码示例
def parse_ground_truth(file_path):
    # 支持CSV和JSON格式
    if file_path.endswith('.csv'):
        return parse_csv_ground_truth(file_path)
    elif file_path.endswith('.json'):
        return parse_json_ground_truth(file_path)

def parse_csv_ground_truth(file_path):
    import csv
    ground_truth = {}
    with open(file_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            filename = row['文件名']
            is_malicious = int(row['是否为恶意'])
            ground_truth[filename] = bool(is_malicious)
    return ground_truth
```

**性能指标计算：**
```python
# 伪代码示例
def performance_evaluation(detection_results, ground_truth):
    # 初始化统计变量
    tp = 0  # True Positive: 正确检测为恶意
    tn = 0  # True Negative: 正确检测为良性
    fp = 0  # False Positive: 错报（良性被检测为恶意）
    fn = 0  # False Negative: 漏报（恶意被检测为良性）
    
    error_files = {
        'false_positive': [],  # 错报文件
        'false_negative': []   # 漏报文件
    }
    
    # 遍历检测结果
    for result in detection_results:
        filename = result['file_info']['filename']
        predicted = result['final_verdict']['is_malicious']
        actual = ground_truth.get(filename)
        
        if actual is None:
            continue  # 跳过没有Ground Truth的文件
        
        if predicted and actual:
            tp += 1
        elif not predicted and not actual:
            tn += 1
        elif predicted and not actual:
            fp += 1
            error_files['false_positive'].append(filename)
        elif not predicted and actual:
            fn += 1
            error_files['false_negative'].append(filename)
    
    # 计算指标
    total = tp + tn + fp + fn
    accuracy = (tp + tn) / total if total > 0 else 0
    precision = tp / (tp + fp) if (tp + fp) > 0 else 0
    recall = tp / (tp + fn) if (tp + fn) > 0 else 0
    false_positive_rate = fp / (fp + tn) if (fp + tn) > 0 else 0
    false_negative_rate = fn / (fn + tp) if (fn + tp) > 0 else 0
    
    return {
        'metrics': {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'false_positive_rate': false_positive_rate,
            'false_negative_rate': false_negative_rate,
            'f1_score': 2 * precision * recall / (precision + recall) if (precision + recall) > 0 else 0
        },
        'confusion_matrix': {
            'true_positive': tp,
            'true_negative': tn,
            'false_positive': fp,
            'false_negative': fn
        },
        'error_files': error_files
    }
```

---

## 4. 数据流设计

### 4.1 单样本检测数据流

```
1. 接收文件上传请求
   ↓
2. 文件验证和存储
   ↓
3. 文件类型识别
   ↓
4. 激活检测模块
   ↓
5. 串行执行检测模块
   ├─→ 静态检测 → 结果1
   ├─→ AI检测 → 结果2
   └─→ 动态检测（如适用）→ 结果3
   ↓
6. 结果整合
   ↓
7. 构建LLM提示词
   ↓
8. 调用LLM API（传递Internet选项）
   ↓
9. 生成Markdown报告
   ↓
10. 返回报告给前端
   ↓
11. 清理临时文件
```

### 4.2 批量检测数据流

```
1. 接收批量文件上传请求
   ↓
2. 文件验证和存储（所有文件）
   ↓
3. 文件类型识别（每个文件）
   ↓
4. 激活检测模块（根据文件类型）
   ↓
5. 任务队列分配
   ↓
6. 并发执行检测（每个文件）
   ├─→ 文件1检测 → 结果1
   ├─→ 文件2检测 → 结果2
   └─→ ...
   ↓
7. 收集所有结果
   ↓
8. （可选）性能评估（如有Ground Truth）
   ↓
9. 生成批量检测报告
   ↓
10. 返回结果给前端
   ↓
11. 清理临时文件
```

---

## 5. 错误处理与异常管理

### 5.1 错误分类

**文件相关错误：**
- 文件过大
- 文件类型不支持
- 文件损坏
- 文件上传失败

**检测模块错误：**
- 模块执行超时
- 模块服务不可用
- 检测结果解析失败

**LLM API错误：**
- API调用超时
- API认证失败
- API配额超限
- 网络连接失败

### 5.2 错误处理策略

**重试机制：**
- 网络请求：最多重试3次，指数退避
- 检测模块：单次失败不重试，记录错误

**降级方案：**
- LLM API失败：返回基础报告模板
- 单个模块失败：返回其他模块结果

**错误日志：**
- 记录详细错误信息
- 记录堆栈跟踪
- 记录请求上下文

---

## 6. 性能优化建议

### 6.1 文件处理优化
- 使用流式处理大文件
- 文件分块上传支持
- 临时文件及时清理

### 6.2 检测模块优化
- 检测结果缓存（相同文件MD5）
- 规则/模型预加载
- 并发检测支持（批量模式）

### 6.3 API响应优化
- 异步处理长时间任务
- WebSocket推送进度更新
- 结果分页返回（批量模式）

### 6.4 资源管理
- 连接池管理（数据库、Redis等）
- 内存使用监控
- 文件句柄及时释放

---

## 7. 安全考虑

### 7.1 文件安全
- 文件大小限制
- 文件类型白名单
- 文件内容扫描（防止恶意脚本）
- 文件存储隔离

### 7.2 API安全
- 请求频率限制（Rate Limiting）
- 身份认证（JWT Token）
- 输入参数验证
- SQL注入防护

### 7.3 数据安全
- 敏感数据加密存储
- 检测结果访问控制
- 日志脱敏处理

---

## 8. 部署建议

### 8.1 环境要求
- Python 3.8+ 或 Node.js 16+
- 足够的磁盘空间（临时文件存储）
- 足够的内存（检测引擎运行）

### 8.2 依赖服务
- Redis（任务队列、缓存）
- 数据库（元数据存储，可选）
- 对象存储（大文件存储，可选）

### 8.3 容器化部署
- Docker镜像构建
- Docker Compose编排
- Kubernetes部署（生产环境）

---

## 9. 测试建议

### 9.1 单元测试
- 各服务模块独立测试
- 检测适配器Mock测试
- 工具函数测试

### 9.2 集成测试
- API接口测试
- 端到端流程测试
- 错误场景测试

### 9.3 性能测试
- 并发请求测试
- 大文件处理测试
- 压力测试

---

## 10. 后续扩展

### 10.1 功能扩展
- 支持更多文件类型
- 支持自定义检测规则
- 支持检测结果对比分析
- 支持检测历史查询

### 10.2 技术扩展
- 分布式检测引擎
- 实时检测流处理
- 机器学习模型在线更新
- 威胁情报自动更新
